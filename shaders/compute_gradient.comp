#version 450
#extension GL_GOOGLE_include_directive : enable

#define M_PI       3.14159265358979323846

#define LIGHT_SOURCE vec3(0.0, 15.0, 10.0)

layout(local_size_x = 16, local_size_y = 16) in;
layout(binding = 0, rgba8) uniform writeonly image2D img;

struct PointLight {
    vec3 position;
    float intensity;
};

struct Ray {
    vec3 origin;
    vec3 direction;
    float minDistance;
    float maxDistance;
};

layout(std430, binding = 3) buffer PointLightBuffer {
    PointLight lights[];
};

layout(std430, binding = 4) buffer LightCounterBuffer {
    uint lightCount;
    uint debug;
};

// NanoVDB buffer & code
layout(binding = 2) readonly buffer NanoVDBBuffer {
    uint pnanovdb_buf_data[];
};
#include "PNanoVDB_GLSL.h"

pnanovdb_buf_t discarded = {0};
pnanovdb_uint32_t gridType;
pnanovdb_readaccessor_t accessor;
pnanovdb_grid_handle_t gridHandle;

void initNanoVolume() {
    pnanovdb_address_t address;
    address.byte_offset = 0;
    gridHandle.address = address;

    pnanovdb_tree_handle_t treeHandle = pnanovdb_grid_get_tree(discarded, gridHandle);
    pnanovdb_root_handle_t rootHandle = pnanovdb_tree_get_root(discarded, treeHandle);
    pnanovdb_readaccessor_init(accessor, rootHandle);
    gridType = pnanovdb_grid_get_grid_type(discarded, gridHandle);
}

bool intersectAABB(vec3 origin, vec3 dir, vec3 boxMin, vec3 boxMax, inout float tmin, inout float tmax) {
    for (int i = 0; i < 3; i++) {
        float invD = 1.0 / dir[i];
        float t0 = (boxMin[i] - origin[i]) * invD;
        float t1 = (boxMax[i] - origin[i]) * invD;
        if (invD < 0.0) {
            float temp = t0; t0 = t1; t1 = temp;
        }
        tmin = max(tmin, t0);
        tmax = min(tmax, t1);
        if (tmax < tmin) return false;
    }
    return true;
}

bool intersectSphere(in Ray ray, in vec3 sphereCenter, in float sphereRadius, out float t)
{
    vec3 oc = ray.origin - sphereCenter;
    float b = dot(oc, ray.direction);
    float c = dot(oc, oc) - sphereRadius * sphereRadius;
    float discriminant = b * b - c;

    if (discriminant < 0.0) {
        // No intersection
        return false;
    }

    float sqrtDisc = sqrt(discriminant);
    float t0 = -b - sqrtDisc;
    float t1 = -b + sqrtDisc;

    // We want the closest positive t
    if (t0 > 0.0) {
        t = t0;
    } else if (t1 > 0.0) {
        t = t1;
    } else {
        // Both intersections are behind the ray origin
        return false;
    }

    return true;
}

bool intersectThickRay(
    vec3 cameraPos, 
    vec3 cameraDir, 
    vec3 lineOrigin, 
    vec3 lineDir, 
    float width,
    out float tHit)
{
    cameraDir = normalize(cameraDir);
    lineDir   = normalize(lineDir);

    vec3 w0 = cameraPos - lineOrigin;

    float a = dot(cameraDir, cameraDir); // ~1.0 if normalized
    float b = dot(cameraDir, lineDir);
    float c = dot(lineDir, lineDir);     // ~1.0 if normalized
    float d = dot(cameraDir, w0);
    float e = dot(lineDir, w0);

    float denom = a * c - b * b;
    if (abs(denom) < 1e-6)
    {
        // Lines are parallel or nearly parallel
        vec3 proj = lineOrigin + e * lineDir;
        float distSq = dot(proj - cameraPos, proj - cameraPos);
        if (distSq <= width * width)
        {
            // If parallel and within width, intersection occurs right at the start (t=0).
            tHit = 0.0;
            return true;
        }
        return false;
    }

    float invDenom = 1.0 / denom;
    float t = (b * e - c * d) * invDenom;
    float s = (a * e - b * d) * invDenom;

    // Compute closest points
    vec3 closestOnCameraRay = cameraPos + cameraDir * t;
    vec3 closestOnLine      = lineOrigin + lineDir * s;

    vec3 diff = closestOnLine - closestOnCameraRay;
    float distSqClosest = dot(diff, diff);

    // Check width and ensure forward direction (t ? 0)
    if (distSqClosest <= width * width && t >= 0.0 && s >= 0.0)
    {
        tHit = t;
        return true;
    }

    return false;
}

bool intersectPointLights(in Ray ray){  // Visualize positions of point lights
    for(uint i = 0; i < lightCount; ++i){
        PointLight light = lights[i];

        float t_discard;
        if(intersectSphere(ray, light.position, 0.5, t_discard))
            return true;
    }
    return false;
}

bool intersectRayLights(in Ray ray){  // Visualize positions of point lights
    for(uint i = 0; i < lightCount; ++i){
        PointLight light = lights[i];

        float t_discard;
        if(intersectThickRay(ray.origin, ray.direction, LIGHT_SOURCE, lights[i].position, 0.1, t_discard)){
            return true;
        }
    }
    return false;
}

vec3 computeLightContribution(vec3 sampleWorldPos) {
    vec3 totalLight = vec3(0.0);
    for (int i = 0; i < lightCount; i++) {
        vec3 L = lights[i].position - sampleWorldPos;
        float dist2 = dot(L, L);
        if (dist2 < 0.0001) continue; // guard against division by zero
        float dist = sqrt(dist2);
        float attenuation = lights[i].intensity / (4.0 * M_PI * dist2);
        totalLight += attenuation * vec3(1.0); // assuming white lights
    }
    return totalLight;
}

void main() {
    initNanoVolume();

    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(img);

    float u = float(pixelCoords.x) / float(imageSize.x);
    float v = float(pixelCoords.y) / float(imageSize.y);

    int width = 256;
    int height = 256;
    vec3 cameraPos = vec3(0.0, 20.0, -125);//-75.0);
    float fov = 45.0;
    float aspectRatio = float(width) / float(height);
    float scale = tan(fov * 0.5 * M_PI / 180.0);

    float x = (2 * (pixelCoords.x + 0.5) / width - 1) * aspectRatio * scale;
    float y = (1 - 2 * (pixelCoords.y + 0.5) / height) * scale;

    Ray ray;
    ray.origin = cameraPos;
    ray.direction = normalize(vec3(x, y, 1.0));
    ray.minDistance = 0.0;
    ray.maxDistance = 15000.0;

    // Transform ray into local index space
    pnanovdb_vec3_t oIndex = pnanovdb_grid_world_to_indexf(discarded, gridHandle, pnanovdb_vec3_t(ray.origin.x, ray.origin.y, ray.origin.z));
    pnanovdb_vec3_t dIndex = pnanovdb_grid_world_to_index_dirf(discarded, gridHandle, pnanovdb_vec3_t(ray.direction.x, ray.direction.y, ray.direction.z));
    
    vec3 rayOriginLocal = vec3(oIndex.x, oIndex.y, oIndex.z);
    vec3 rayDirLocal = normalize(vec3(dIndex.x, dIndex.y, dIndex.z));

    pnanovdb_tree_handle_t tree = pnanovdb_grid_get_tree(discarded, gridHandle);
    pnanovdb_root_handle_t root = pnanovdb_tree_get_root(discarded, tree);

    pnanovdb_coord_t bboxMinI = pnanovdb_root_get_bbox_min(discarded, root);
    pnanovdb_coord_t bboxMaxI = pnanovdb_root_get_bbox_max(discarded, root);

    vec3 boxMin = vec3(bboxMinI.x, bboxMinI.y, bboxMinI.z);
    vec3 boxMax = vec3(bboxMaxI.x + 1, bboxMaxI.y + 1, bboxMaxI.z + 1);

    float tmin = ray.minDistance;
    float tmax = ray.maxDistance;
    bool hitVolume = intersectAABB(rayOriginLocal, rayDirLocal, boxMin, boxMax, tmin, tmax);

    vec3 finalColor = vec3(0.0);
    if (hitVolume && tmax > 0.0) {
        tmin = max(tmin, 0.0);
        float stepSize = 1.0;
        float t = tmin;
        
        float T = 1.0; // transmittance
        float absorptionCoefficient = 1.0;

        while (t < tmax && T > 0.001) {
            vec3 pLocal = rayOriginLocal + rayDirLocal * t;
            
            // Convert pLocal back to world space for correct lighting calculations
            pnanovdb_vec3_t pWorldNano = pnanovdb_grid_index_to_worldf(discarded, gridHandle, pnanovdb_vec3_t(pLocal.x, pLocal.y, pLocal.z));
            vec3 pWorld = vec3(pWorldNano.x, pWorldNano.y, pWorldNano.z);

            ivec3 ijk = ivec3(floor(pLocal.x), floor(pLocal.y), floor(pLocal.z));

            if (ijk.x >= bboxMinI.x && ijk.y >= bboxMinI.y && ijk.z >= bboxMinI.z &&
                ijk.x <= bboxMaxI.x && ijk.y <= bboxMaxI.y && ijk.z <= bboxMaxI.z) {

                pnanovdb_address_t addr = pnanovdb_readaccessor_get_value_address(gridType, discarded, accessor, ijk);
                float val = pnanovdb_read_float(discarded, addr);

                // Compute incoming light at this point in world space
                vec3 lightIncoming = computeLightContribution(pWorld);

                vec3 dC = T * val * stepSize * lightIncoming;
                finalColor += dC;

                float attenuation = exp(-val * absorptionCoefficient * stepSize);
                T *= attenuation;
            }

            t += stepSize;
        }
    }

    // debugging tryout
    //lights[0].position = vec3(5,0,0);
    //lights[1].position = vec3(1,1,1);
    //lights[2].position = vec3(2,2,5);


    float t_discard;

    /*hit = intersectThickRay(ray.origin, ray.direction, lights[0].position, lights[1].position, 3, t_discard);
    if(hit){
        finalColor = lights[1].position;
    }*/

    /*if(lightCount > 10){
        finalColor = vec3(0,1,1);
    }*/

    bool hit = intersectPointLights(ray);
    if(hit){
        finalColor = vec3(0,1,1);
    }

    /*if(debug > 1){
        finalColor = vec3(0,01,0);
    }else{
        finalColor = vec3(01,0,0);
    }*/


    vec3 displayedColor = clamp(finalColor, 0.0, 1.0);
    vec4 color = vec4(displayedColor, 1.0);
    imageStore(img, pixelCoords, color);
}